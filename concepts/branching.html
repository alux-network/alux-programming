<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Branching and Confluence - ALUX programming guidelines</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/index.css">
        <link rel="stylesheet" href="../theme/mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ALUX programming guidelines</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/alux-network/alux-programming" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/alux-network/alux-programming/edit/master/src/concepts/branching.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="branching-and-confluence"><a class="header" href="#branching-and-confluence">Branching and Confluence</a></h1>
<p>We encounter <strong>branching</strong> constantly in everyday life.
Imagine:</p>
<ul>
<li>You wake up and decide: ‚òï coffee <strong>or</strong> üçµ tea.</li>
<li>If coffee: sugar or no sugar?</li>
<li>If tea: green or black?</li>
</ul>
<p>Each decision <strong>branches</strong> into alternatives, like a little decision tree.
But in the end, you don‚Äôt live in two universes ‚Äî you end up with <strong>one drink in your hand</strong>.
That‚Äôs <strong>confluence</strong>: although choices branch, they merge back into one reality.</p>
<h2 id="branching-in-rust-programs"><a class="header" href="#branching-in-rust-programs">Branching in Rust Programs</a></h2>
<p>The same pattern appears in programs. A sequential program may branch internally, but execution always continues as a <strong>single flow</strong>.</p>
<h3 id="if"><a class="header" href="#if"><code>if</code></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sign(x: i32) -&gt; i32 {
    if x &gt; 0 {
        1
    } else if x &lt; 0 {
        -1
    } else {
        0
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Branching:</strong> program splits into one of three paths.</li>
<li><strong>Confluence:</strong> for a given input value, the same branch condition will always be chosen. Each input deterministically follows exactly one path, and evaluation of conditions happens in a fixed order (first check <code>x &gt; 0</code>, then <code>x &lt; 0</code>, else default). Regardless of which path is taken, the result is always determined from the input, and execution continues in a single, unified flow.</li>
</ul>
<h3 id="match"><a class="header" href="#match"><code>match</code></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn day_type(day: &amp;str) -&gt; &amp;str {
    match day {
        "Saturday" | "Sunday" =&gt; "Weekend",
        "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" =&gt; "Weekday",
        _ =&gt; "Unknown",
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Branching:</strong> many alternatives.</li>
<li><strong>Confluence:</strong> for a given input value, the program deterministically selects exactly one matching branch. The essential property is that the <em>trace</em> of evaluation is deterministic: the same input always leads down the same path. In this simple example each branch yields the same type (<code>&amp;str</code>), but even in settings with dependent types‚Äîwhere result types vary with input‚Äîthe execution remains confluent because identical inputs always produce the same path and outcome.</li>
</ul>
<h3 id="loops-with-early-exit"><a class="header" href="#loops-with-early-exit">Loops with Early Exit</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_even(nums: &amp;[i32]) -&gt; Option&lt;i32&gt; {
    for &amp;n in nums {
        if n % 2 == 0 {
            return Some(n); // branch: exit early
        }
    }
    None // confluence: reached if loop completes
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Branching:</strong> may exit during iteration.</li>
<li><strong>Confluence:</strong> one thread of control ‚Äî either returns early or finishes and continues.</li>
</ul>
<h2 id="sequential-confluence-illustrated"><a class="header" href="#sequential-confluence-illustrated">Sequential Confluence Illustrated</a></h2>
<pre><code>Start
 ‚îú‚îÄ branch A ‚Üí ...
 ‚îî‚îÄ branch B ‚Üí ...
           ‚Üò
            Confluence ‚Üí continues as one flow
</code></pre>
<p>Just like your morning drink decision, a program doesn‚Äôt split into parallel worlds.
Branches are <strong>local alternatives</strong>, but <strong>sequential confluence</strong> ensures only one actual path is taken, and execution rejoins into one future.</p>
<p>‚ö° <strong>Key idea:</strong>
Branching explores alternatives, confluence merges them back.
In sequential programs, <strong>confluence is guaranteed</strong>: there‚Äôs always one final thread of execution.</p>
<h2 id="confluence-beyond-determinism"><a class="header" href="#confluence-beyond-determinism">Confluence Beyond Determinism</a></h2>
<p>Confluence is often explained as the guarantee that the same input always produces the same output. But its essence is deeper: <strong>the trace of evaluation itself is deterministic</strong>. This means the path through the program is uniquely determined by the input, independent of external factors. In Rust, both <code>if</code> and <code>match</code> enforce deterministic traces. More broadly, confluence is what allows reasoning about programs algebraically, since the same input always reduces in a predictable way.</p>
<h2 id="trace-equivalence"><a class="header" href="#trace-equivalence">Trace Equivalence</a></h2>
<p><strong>Trace equivalence</strong> means that two programs, given the same input, follow evaluation paths that yield the <strong>same observable behavior</strong>: the same result and the same observable effects. In pure code (no effects), this reduces to producing the same result for all inputs. With side effects, equivalence also requires that the same conditions are evaluated in the same order.</p>
<p><strong>Example of not trace‚Äëequivalent (side effect changes trace):</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_admin() -&gt; bool {
    println!("checked admin"); // side effect
    true
}
fn is_user() -&gt; bool {
    println!("checked user"); // side effect
    true
}

fn classify_role(x: i32) -&gt; &amp;'static str {
    if is_admin() {
        "admin"
    } else if is_user() {
        "user"
    } else {
        "other"
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here both <code>is_admin</code> and <code>is_user</code> return <code>true</code>, so the result is always <code>"admin"</code>. But the <strong>trace differs</strong>: if <code>is_admin</code> is checked first, only that prints; if conditions are reordered, <code>is_user</code> prints instead. The outcome is the same, but the traces differ, so the programs are <strong>not trace‚Äëequivalent</strong>.</p>
<p><strong>Trace‚Äëequivalent reorder (pure, disjoint, total):</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn classify_a(x: i32) -&gt; &amp;'static str {
    if x &lt; 0 { "neg" } else if x == 0 { "zero" } else { "pos" }
}
fn classify_b(x: i32) -&gt; &amp;'static str {
    if x == 0 { "zero" } else if x &lt; 0 { "neg" } else { "pos" }
}
<span class="boring">}</span></code></pre></pre>
<p>The predicates are disjoint and cover all integers; both versions return the same label for every input. With no side effects, these are <strong>trace‚Äëequivalent</strong>.</p>
<h2 id="bridge-to-trees"><a class="header" href="#bridge-to-trees">Bridge to Trees</a></h2>
<p>Branching in programs naturally connects to tree structures. A sequence of decisions can be visualized as a decision tree: each internal node is a branching point, and each leaf is a possible outcome. Restricting to two alternatives at each branch gives <strong>binary trees</strong>, which are a cornerstone of computer science. This perspective shifts branching from a control-flow mechanism into a structural representation of possibilities.</p>
<p>Conal Elliott has described memory addressing as a kind of <strong>perfect binary leaf trees</strong>, where each memory cell corresponds to a leaf reached by a sequence of left/right choices. This view links the abstract branching structure of programs to the very way data is organized and accessed.</p>
<iframe width="100%" height="315" src="https://www.youtube.com/embed/oaIMMclGuog?si=qGfA1CWoDyXuInHA&amp;clip=Ugkx_TTQq7uzqaz9F1my5lozpOJ9cusgqSG3&amp;clipt=ELD_mwEY0LOeAQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<h2 id="bridge-to-semantics"><a class="header" href="#bridge-to-semantics">Bridge to Semantics</a></h2>
<p>Confluence is also a fundamental property in programming language semantics. In lambda calculus, for example, the <strong>Church‚ÄìRosser theorem</strong> states that if an expression can be reduced in different ways, all reduction paths will converge to a common result. This reflects the same guarantee as sequential confluence in Rust: different branches don‚Äôt lead to diverging realities but ultimately rejoin into one meaning. This bridge from everyday branching to formal semantics helps build intuition for deeper topics in programming theory.</p>
<h2 id="bridge-to-bisimulation"><a class="header" href="#bridge-to-bisimulation">Bridge to Bisimulation</a></h2>
<p>Another important concept related to branching is <strong>bisimulation</strong>, used in process calculi and concurrency theory. Two systems are bisimilar if they can simulate each other‚Äôs steps: whenever one makes a move, the other can make a corresponding move, and the resulting states remain related. Unlike simple trace equivalence, bisimulation is sensitive to the structure of branching, not just final results. It ensures that two programs behave the same way under every possible interaction, making it a powerful tool for reasoning about equivalence in concurrent and interactive systems.</p>
<p>There are different <strong>flavors</strong> of bisimulation:</p>
<ul>
<li><strong>Strong bisimulation</strong> ‚Äì requires that every single step of one process can be matched by an identical step in the other, including internal or invisible actions.</li>
<li><strong>Weak bisimulation</strong> ‚Äì abstracts away from internal or silent actions (often denoted œÑ). Two systems can be weakly bisimilar if they match on observable behavior, even if one performs extra internal steps.</li>
<li><strong>Branching bisimulation</strong> ‚Äì a refinement of weak bisimulation that preserves the branching structure more carefully: even when ignoring internal actions, the branching points must align so that the choice structure is respected.</li>
</ul>
<p>These distinctions are crucial in concurrency theory: strong bisimulation is very strict, weak bisimulation allows flexibility with internal computation, and branching bisimulation balances the two by maintaining the essential shape of choices while abstracting from unobservable details.</p>
<h2 id="confluence-and-bisimulation-compared"><a class="header" href="#confluence-and-bisimulation-compared">Confluence and Bisimulation Compared</a></h2>
<p>Although confluence and bisimulation both deal with branching and outcomes, they apply in different contexts:</p>
<ul>
<li><strong>Confluence</strong> is about <strong>deterministic evaluation</strong>: for the same input, all reduction paths lead to the same result. It is mainly used in sequential semantics (e.g., lambda calculus) to prove consistency and simplify reasoning.</li>
<li><strong>Bisimulation</strong> is about <strong>behavioral equivalence</strong> between two possibly concurrent systems: whenever one system can make a step, the other can match it. It is mainly used in process calculi and concurrency theory to establish that two processes behave the same under all possible interactions.</li>
</ul>
<p>In short:</p>
<ul>
<li>Confluence ‚Üí guarantees <strong>one meaning</strong> for each program.</li>
<li>Bisimulation ‚Üí guarantees <strong>two programs mean the same</strong> in terms of behavior.</li>
</ul>
<p>These notions complement each other: confluence helps ensure determinism in sequential computation, while bisimulation provides a robust notion of equivalence in concurrent or interactive computation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../concepts/dependent_types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../insights/operational_semantics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../concepts/dependent_types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../insights/operational_semantics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
