<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ALUX programming guidelines</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/index.css">
        <link rel="stylesheet" href="theme/mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ALUX programming guidelines</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/alux-network/alux-programming" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="index.html#admonition-warning"></a>
</div>
<div>
<p>This book is in an early stage.</p>
</div>
</div>
<h1 id="alux-programming-guidelines"><a class="header" href="#alux-programming-guidelines"><img src="assets/alux-logo.png" style="margin-right: 10px; border-radius: 50%; background: white;"> ALUX Programming Guidelines</a></h1>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="index.html#admonition-note"></a>
</div>
<div>
<p>This book is a guide to writing programs by defining their meaning first and their mechanics second.</p>
<p>Inspired by Conal Elliott’s Denotational Design, it treats computation as a clear mathematical object rather than an opaque sequence of steps.</p>
<p>Specifications are expressed as simple, compositional traits that describe <em>what</em> a program is. Implementations provide interchangeable ways to <em>realise</em> those meanings.</p>
<p>The result is software that is easier to reason about, naturally composable, and correct by construction.</p>
</div>
</div>
<h2 id="how-to-read-this-book"><a class="header" href="#how-to-read-this-book">How to Read This Book</a></h2>
<p>This book blends theory and practice. You will see each concept from <strong>two perspectives</strong>:</p>
<ul>
<li><strong>Concepts</strong> — core ideas expressed clearly and precisely, independent of language or framework.</li>
<li><strong>Insights</strong> — deeper connections between concepts, with examples, design patterns, and transformations.</li>
</ul>
<p>The examples are often in Rust but the principles are language-agnostic.</p>
<h2 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who This Book Is For</a></h2>
<ul>
<li>Programmers who want to <strong>design for meaning</strong> rather than just mechanics.</li>
<li>Developers seeking to <strong>connect category theory, type systems, and program design</strong>.</li>
<li>Readers curious about how ideas like <strong>Free Monads</strong>, <strong>CPS</strong>, <strong>Defunctionalization</strong>, and <strong>Dependent Types</strong> fit together.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="operational-semantics"><a class="header" href="#operational-semantics">Operational Semantics</a></h1>
<div id="admonition-related" class="admonition admonish-tip" role="note" aria-labelledby="admonition-related-title">
<div class="admonition-title">
<div id="admonition-related-title">
<p>Related</p>
</div>
<a class="admonition-anchor-link" href="concepts/operational_semantics.html#admonition-related"></a>
</div>
<div>
<p>Concepts: <a href="concepts/../concepts/free_monad.html">Free Monad</a>, <a href="concepts/../concepts/cps.html">CPS</a>, <a href="concepts/../concepts/defunctionalization.html">Defunctionalization</a><br />
Insights: <a href="concepts/../insights/operational_semantics.html">Operational Semantics in Context</a></p>
</div>
</div>
<h3 id="definition"><a class="header" href="#definition">Definition</a></h3>
<p><strong>Operational semantics</strong> defines the meaning of programs by specifying <em>how they execute step by step</em>. It models program execution as transitions between <strong>configurations</strong> - abstract states containing program fragments, environments, or memory.</p>
<h2 id="styles-of-operational-semantics"><a class="header" href="#styles-of-operational-semantics">Styles of Operational Semantics</a></h2>
<h3 id="small-step-structural-operational-semantics"><a class="header" href="#small-step-structural-operational-semantics">Small-step (Structural Operational Semantics)</a></h3>
<p>Computation is broken into atomic transitions:</p>
<pre><code class="language-hs">(2 + 3) → 5
(2 + 3) * 4 → 5 * 4 → 20
</code></pre>
<p>Useful for modeling concurrency, interleaving, and partial execution.</p>
<h3 id="big-step-natural-semantics"><a class="header" href="#big-step-natural-semantics">Big-step (Natural Semantics)</a></h3>
<p>Describes evaluation in terms of final results:</p>
<pre><code class="language-hs">(2 + 3) * 4 ⇓ 20
</code></pre>
<p>Often clearer for reasoning about terminating programs.</p>
<h2 id="formal-rules"><a class="header" href="#formal-rules">Formal Rules</a></h2>
<p>Operational semantics is typically given with <strong>inference rules</strong>.<br />
For a simple arithmetic language:</p>
<pre><code class="language-hs">Expr ::= n | Expr + Expr
</code></pre>
<p>We can write:</p>
<pre><code>n1 + n2 → n3      (where n3 = n1 + n2)
</code></pre>
<p>Evaluation trace:</p>
<pre><code class="language-hs">(1 + 2) + 3 → 3 + 3 → 6
</code></pre>
<h2 id="why-it-matters"><a class="header" href="#why-it-matters">Why It Matters</a></h2>
<ul>
<li>Provides a <strong>precise machine-like model</strong> of execution.</li>
<li>Foundation for interpreters and virtual machines.</li>
<li>Supports reasoning about correctness, resource use, and safety.</li>
</ul>
<h2 id="relation-to-other-concepts"><a class="header" href="#relation-to-other-concepts">Relation to Other Concepts</a></h2>
<ul>
<li><strong>Free Monad</strong>: Encodes operational rules as an AST of instructions.</li>
<li><strong>CPS</strong>: Makes control flow explicit by turning "rest of the program" into a continuation.</li>
<li><strong>Defunctionalization</strong>: Turns continuations into explicit state transitions, directly resembling operational semantics.</li>
<li><strong>Dependent Types</strong>: Can enrich operational rules with proofs (e.g., stack safety, gas bounds).</li>
</ul>
<h2 id="in-practice"><a class="header" href="#in-practice">In Practice</a></h2>
<p>Operational semantics is how interpreters are built:</p>
<ul>
<li>The <strong>EVM</strong> can be viewed as a large-step state transition system.</li>
<li>Small-step rules directly resemble <code>match</code> arms in a Rust interpreter.</li>
</ul>
<pre><code>(n1 + n2) → n3
</code></pre>
<p>can be read as Rust code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match expr {
    Add(Box::new(Num(n1)), Box::new(Num(n2))) =&gt; Num(n1 + n2),
    _ =&gt; expr,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="to-think-about"><a class="header" href="#to-think-about">To think about</a></h2>
<p>Thinking about programming in operational ways or using an imperative style—even with a proof—does not enable us to gain deep insights</p>
<iframe width="100%" height="315" src="https://www.youtube.com/embed/n2CBSNAVHVg?si=jx2yItB8ZvudwCr1&amp;clip=UgkxKN5lzq4a3MYoVuIS777H2gAV9GZt7wRz&amp;clipt=EMjRxAUYh-jHBQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>Operational thinking (implementation first) prevent us to express and improve ideas</p>
<iframe width="100%" height="315" src="https://www.youtube.com/embed/n2CBSNAVHVg?si=8imhBQPvY7AS-Nld&amp;clip=UgkxNwvDlj5QXGj_A9GAyZm4hQsq9cXeiOqe&amp;clipt=EL3qrwMYmuSxAw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="free-monad"><a class="header" href="#free-monad">Free Monad</a></h1>
<div id="admonition-related" class="admonition admonish-tip" role="note" aria-labelledby="admonition-related-title">
<div class="admonition-title">
<div id="admonition-related-title">
<p>Related</p>
</div>
<a class="admonition-anchor-link" href="concepts/free_monad.html#admonition-related"></a>
</div>
<div>
<p>Concepts: <a href="concepts/../concepts/dependent_types.html">Dependent types</a>, <a href="concepts/../concepts/cps.html">CPS</a>, <a href="concepts/../concepts/defunctionalization.html">Defunctionalization</a><br />
Insights: <a href="concepts/../insights/evm-alg.html">Mini EVM</a>, <a href="concepts/../insights/free-monad-dependent.html">Free Monad (dependently)</a></p>
</div>
</div>
<h2 id="1-what-is-a-free-monad-rust-version"><a class="header" href="#1-what-is-a-free-monad-rust-version"><strong>1. What is a Free Monad (Rust version)</strong></a></h2>
<p>A <strong>free monad</strong> lets you:</p>
<ul>
<li><strong>Describe</strong> a program as <em>data</em> - not by running it right away.</li>
<li><strong>Interpret</strong> that program later in one or more ways.</li>
</ul>
<p>Think of it as:</p>
<blockquote>
<p>An AST of effectful operations + <code>bind</code>/<code>flat_map</code> to chain them.</p>
</blockquote>
<p>You split:</p>
<ul>
<li><strong>Syntax</strong> → enum of instructions.</li>
<li><strong>Semantics</strong> → interpreter function.</li>
</ul>
<p>“Free” means you can build a monad <strong>from any functor</strong> (<code>F</code>) without committing to meaning.</p>
<h2 id="2-rust-implementation"><a class="header" href="#2-rust-implementation"><strong>2. Rust Implementation</strong></a></h2>
<h3 id="free-monad-type"><a class="header" href="#free-monad-type">Free Monad type</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
enum Free&lt;F, A&gt; {
    Pure(A),
    Suspend(F),
    FlatMap(Box&lt;Free&lt;F, A&gt;&gt;, Box&lt;dyn Fn(A) -&gt; Free&lt;F, A&gt;&gt;),
}

impl&lt;F: Clone + 'static, A: 'static&gt; Free&lt;F, A&gt; {
    fn pure(a: A) -&gt; Self {
        Free::Pure(a)
    }

    fn flat_map&lt;B: 'static, G&gt;(self, f: G) -&gt; Free&lt;F, B&gt;
    where
        G: Fn(A) -&gt; Free&lt;F, B&gt; + 'static,
        F: 'static,
    {
        match self {
            Free::Pure(a) =&gt; f(a),
            Free::Suspend(op) =&gt; {
                Free::FlatMap(Box::new(Free::Suspend(op)), Box::new(f))
            }
            Free::FlatMap(inner, g) =&gt; {
                Free::FlatMap(inner, Box::new(move |x| g(x).flat_map(f.clone())))
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="dsl-console-operations"><a class="header" href="#dsl-console-operations">DSL: Console operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
enum Console&lt;A&gt; {
    Print(String, A),
    ReadLine(fn(String) -&gt; A),
}

// Smart constructors
fn print_line(s: &amp;str) -&gt; Free&lt;Console&lt;()&gt;, ()&gt; {
    Free::Suspend(Console::Print(s.to_string(), ()))
}

fn read_line() -&gt; Free&lt;Console&lt;String&gt;, String&gt; {
    Free::Suspend(Console::ReadLine(|input| Free::Pure(input)))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="interpreter"><a class="header" href="#interpreter">Interpreter</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_console&lt;A&gt;(mut prog: Free&lt;Console&lt;A&gt;, A&gt;) -&gt; A {
    loop {
        match prog {
            Free::Pure(a) =&gt; return a,
            Free::Suspend(Console::Print(s, next)) =&gt; {
                println!("{}", s);
                prog = Free::Pure(next);
            }
            Free::Suspend(Console::ReadLine(f)) =&gt; {
                let mut buf = String::new();
                std::io::stdin().read_line(&amp;mut buf).unwrap();
                prog = f(buf.trim().to_string());
            }
            Free::FlatMap(inner, cont) =&gt; match *inner {
                Free::Pure(a) =&gt; prog = cont(a),
                Free::Suspend(op) =&gt; prog = Free::Suspend(op), // minimal handling
                _ =&gt; unimplemented!(),
            },
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let program =
        print_line("What is your name?")
        .flat_map(|_| read_line())
        .flat_map(|name| print_line(&amp;format!("Hello, {name}!")));

    run_console(program);
}</code></pre></pre>
<h2 id="3-takeaway"><a class="header" href="#3-takeaway"><strong>3. Takeaway</strong></a></h2>
<ul>
<li><strong>Syntax</strong> = <code>enum Console</code> (possible instructions)</li>
<li><strong>Program</strong> = <code>Free&lt;Console, A&gt;</code> (data describing steps)</li>
<li><strong>Semantics</strong> = <code>run_console</code> (interpreter)</li>
<li>Benefit: You can write multiple interpreters for the same program — e.g., run in real IO, log to a file, or compile to another language.</li>
</ul>
<h2 id="correlation-to-continuations-and-cps"><a class="header" href="#correlation-to-continuations-and-cps"><strong>Correlation to Continuations and CPS</strong></a></h2>
<p><strong>Continuation-Passing Style (CPS)</strong> is a way of writing programs where functions never return values directly but instead pass results to another function (the <em>continuation</em>) that represents “the rest of the program.”</p>
<p>A <strong>free monad</strong> is basically a <strong>program as a sequence of steps</strong>, where each step says:</p>
<blockquote>
<p>"Do this, then continue with the rest."</p>
</blockquote>
<p>That “rest of the program” is exactly a <strong>continuation</strong> — a function from the current result to the next step.</p>
<ul>
<li>
<p>In our Rust free monad:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Free::FlatMap(Box&lt;Free&lt;F, A&gt;&gt;, Box&lt;dyn Fn(A) -&gt; Free&lt;F, A&gt;&gt;)
<span class="boring">}</span></code></pre></pre>
<p>the <code>Box&lt;dyn Fn(A) -&gt; Free&lt;F, A&gt;&gt;</code> <strong>is the continuation</strong>.</p>
</li>
<li>
<p>When you interpret a free monad, you are <strong>running in CPS</strong>:</p>
<ul>
<li>Instead of returning values directly, you pass them into the next continuation.</li>
<li>You end up in a loop of:
<code>current_instruction -&gt; feed result into continuation -&gt; next instruction</code></li>
</ul>
</li>
<li>
<p><strong>CPS relation</strong>:</p>
<ul>
<li>Free monads <em>encode CPS in a data structure</em>.</li>
<li>CPS <em>is the runtime control flow representation</em> of the same idea.</li>
</ul>
</li>
</ul>
<p><strong>Quick mapping</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>Concept</th><th>In CPS</th><th>In Free Monad AST</th></tr></thead><tbody>
<tr><td>Step result</td><td>Argument to continuation</td><td><code>A</code> in <code>Fn(A) -&gt; Free</code></td></tr>
<tr><td>Continuation</td><td>Function <code>(A) -&gt; R</code></td><td><code>Box&lt;dyn Fn(A) -&gt; Free&gt;</code></td></tr>
<tr><td>Program</td><td>Nested continuations</td><td>Nested <code>FlatMap</code> variants</td></tr>
<tr><td>Execution</td><td>Calling functions</td><td>Pattern matching + calling</td></tr>
</tbody></table>
</div>
<h2 id="gof-design-patterns-mapping"><a class="header" href="#gof-design-patterns-mapping"><strong>GoF Design Patterns Mapping</strong></a></h2>
<p>Free monads are <strong>not</strong> in GoF because they’re from functional programming theory, but they <strong>subsume</strong> or <strong>emulate</strong> several patterns:</p>
<div class="table-wrapper"><table><thead><tr><th>GoF Pattern</th><th>How Free Monad Relates</th></tr></thead><tbody>
<tr><td><strong>Interpreter</strong></td><td>The whole “AST + run” is literally Interpreter pattern — free monads just give you the AST + combinators for free.</td></tr>
<tr><td><strong>Command</strong></td><td>Each <code>enum</code> variant in the DSL is a Command object. The free monad chains them like a macro-command.</td></tr>
<tr><td><strong>Composite</strong></td><td>The AST structure (nested instructions) is a Composite of commands.</td></tr>
<tr><td><strong>Builder</strong></td><td>The <code>.flat_map</code> chain is a fluent builder for programs.</td></tr>
<tr><td><strong>Visitor</strong></td><td>The interpreter is essentially a visitor over the instruction set.</td></tr>
</tbody></table>
</div>
<h2 id="why-free-monad--these-patterns"><a class="header" href="#why-free-monad--these-patterns"><strong>Why Free Monad &gt; These Patterns</strong></a></h2>
<ul>
<li>
<p>GoF patterns are <strong>manual OOP work</strong> - you define interfaces, classes, and compose them.</p>
</li>
<li>
<p>Free monads are <strong>algebraic</strong> - you define <em>data</em> for instructions and <em>functions</em> to interpret them.</p>
</li>
<li>
<p>You automatically get:</p>
<ul>
<li>Sequencing (<code>flat_map</code>)</li>
<li>Composition</li>
<li>Multiple interpreters without touching core logic</li>
</ul>
</li>
</ul>
<p><strong>Summary Table</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>Free Monad FP concept</th><th>Equivalent GoF/OOP pattern</th></tr></thead><tbody>
<tr><td>Instruction enum</td><td>Command</td></tr>
<tr><td>Program AST</td><td>Composite</td></tr>
<tr><td><code>flat_map</code> builder</td><td>Builder</td></tr>
<tr><td>Interpreter fn</td><td>Interpreter / Visitor</td></tr>
<tr><td>Multiple interpreters</td><td>Strategy</td></tr>
</tbody></table>
</div>
<h2 id="relation-to-defunctionalization"><a class="header" href="#relation-to-defunctionalization"><strong>Relation to Defunctionalization</strong></a></h2>
<p><strong>Defunctionalization</strong> is a program transformation that replaces higher-order functions with a first-order data structure that represents the possible functions, plus an interpreter that applies them.</p>
<p>In CPS, continuations are higher-order functions. Defunctionalizing a CPS program replaces those continuations with an enum of continuation cases and an <code>apply</code> function to run them.</p>
<p>A free monad can be seen as the result of defunctionalizing the continuations inside a CPS-transformed program:</p>
<ol>
<li>Start with a CPS version of your program. The "rest of the program" is carried in continuation functions.</li>
<li>Defunctionalize those continuation functions into a finite set of cases in a data type.</li>
<li>The resulting data type, together with the initial instruction set, is exactly the AST of a free monad.</li>
</ol>
<p><strong>Key similarities</strong></p>
<ul>
<li>Both free monads and defunctionalization produce a data representation of computation and require an interpreter to give meaning to that data.</li>
<li>The <code>FlatMap</code> case in a free monad holds the continuation; defunctionalization replaces that closure with a case in a data type.</li>
</ul>
<p><strong>Key differences</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Defunctionalization</th><th>Free Monad</th></tr></thead><tbody>
<tr><td>Purpose</td><td>Mechanical compiler technique to remove higher-order functions</td><td>Algebraic construction to separate syntax from semantics</td></tr>
<tr><td>Input</td><td>Any higher-order program, often in CPS form</td><td>A functor F describing possible instructions</td></tr>
<tr><td>Output</td><td>Enum of function cases plus apply function</td><td><code>Free&lt;F, A&gt;</code> AST plus interpreters</td></tr>
<tr><td>Monad?</td><td>Not necessarily</td><td>Always a monad by construction</td></tr>
<tr><td>Scope</td><td>General transformation</td><td>Specific functional programming pattern</td></tr>
</tbody></table>
</div>
<p><strong>Summary</strong>
Defunctionalization is a transformation technique. Free monads are a reusable design pattern. The free monad structure is what you get when you defunctionalize the continuations in a CPS program built from a functor F.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="continuation-passing-style-cps"><a class="header" href="#continuation-passing-style-cps">Continuation-Passing Style (CPS)</a></h1>
<div id="admonition-related" class="admonition admonish-tip" role="note" aria-labelledby="admonition-related-title">
<div class="admonition-title">
<div id="admonition-related-title">
<p>Related</p>
</div>
<a class="admonition-anchor-link" href="concepts/cps.html#admonition-related"></a>
</div>
<div>
<p>Concepts: <a href="concepts/../concepts/free_monad.html">Free Monad</a>, <a href="concepts/../concepts/defunctionalization.html">Defunctionalization</a><br />
Insights: <a href="concepts/../insights/evm-alg.html">Mini EVM</a></p>
</div>
</div>
<h3 id="definition-1"><a class="header" href="#definition-1">Definition</a></h3>
<p>Continuation-Passing Style (CPS) is a way of writing programs where functions do not return values directly. Instead, they pass their result to another function called a <em>continuation</em>, which represents the rest of the program.</p>
<h3 id="motivation"><a class="header" href="#motivation">Motivation</a></h3>
<ul>
<li>Makes control flow explicit and programmable.</li>
<li>Enables advanced transformations such as non-blocking IO, early exits, coroutines, backtracking, and concurrency scheduling.</li>
<li>Used in compiler intermediate representations to simplify optimization and analysis.</li>
</ul>
<h3 id="basic-form"><a class="header" href="#basic-form">Basic Form</a></h3>
<p>In direct style:</p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn main() {
    let y = add_one(41);
    println!("{}", y);
}</code></pre></pre>
<p>In CPS:</p>
<pre><pre class="playground"><code class="language-rust">fn add_one_cps(x: i32, k: impl Fn(i32)) {
    k(x + 1)
}

fn main() {
    add_one_cps(41, |y| {
        println!("{}", y);
    });
}</code></pre></pre>
<p>Here, <code>k</code> is the continuation. Instead of returning <code>x + 1</code>, we call <code>k(x + 1)</code>.</p>
<h3 id="key-properties"><a class="header" href="#key-properties">Key Properties</a></h3>
<ul>
<li>All function calls are <em>tail calls</em> to continuations.</li>
<li>The current computation never "returns" to the caller; instead it jumps into the continuation.</li>
<li>Control flow becomes explicit in the program.</li>
</ul>
<h3 id="relation-to-higher-order-functions"><a class="header" href="#relation-to-higher-order-functions">Relation to Higher-Order Functions</a></h3>
<ul>
<li>In CPS, continuations are just higher-order functions.</li>
<li>Each step of the computation receives a continuation representing what to do next.</li>
</ul>
<h3 id="relation-to-defunctionalization-1"><a class="header" href="#relation-to-defunctionalization-1">Relation to Defunctionalization</a></h3>
<ul>
<li>In CPS, the continuation is an actual function value.</li>
<li>Defunctionalization replaces the continuation function with a data structure (enum) that represents possible next steps, plus an <code>apply</code> function to interpret them.</li>
</ul>
<h3 id="relation-to-free-monads"><a class="header" href="#relation-to-free-monads">Relation to Free Monads</a></h3>
<ul>
<li>The <code>FlatMap</code> constructor in a free monad is exactly a stored continuation.</li>
<li>Interpreting a free monad is like executing CPS code where the continuation is part of the program data.</li>
<li>Free monads can be obtained by taking CPS code and defunctionalizing the continuations.</li>
</ul>
<h3 id="advantages"><a class="header" href="#advantages">Advantages</a></h3>
<ul>
<li>Flexible control flow representation.</li>
<li>Easier to reason about evaluation order.</li>
<li>Powerful for implementing interpreters, debuggers, optimizers, and async runtimes.</li>
</ul>
<h3 id="disadvantages"><a class="header" href="#disadvantages">Disadvantages</a></h3>
<ul>
<li>Verbose compared to direct style.</li>
<li>Can be harder to read for humans.</li>
<li>Requires tail call optimization for efficiency in languages without native support for it.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="defunctionalization"><a class="header" href="#defunctionalization">Defunctionalization</a></h1>
<div id="admonition-related" class="admonition admonish-tip" role="note" aria-labelledby="admonition-related-title">
<div class="admonition-title">
<div id="admonition-related-title">
<p>Related</p>
</div>
<a class="admonition-anchor-link" href="concepts/defunctionalization.html#admonition-related"></a>
</div>
<div>
<p>Concepts: <a href="concepts/../concepts/free_monad.html">Free Monad</a>, <a href="concepts/../concepts/cps.html">CPS</a><br />
Insights: <a href="concepts/../insights/evm-alg.html">Mini EVM</a></p>
</div>
</div>
<h3 id="definition-2"><a class="header" href="#definition-2">Definition</a></h3>
<p>Defunctionalization is a program transformation that replaces higher-order functions with a first-order data structure that represents the possible functions, plus an interpreter function that applies them.</p>
<h3 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h3>
<p>Some languages, compilers, or runtimes cannot handle higher-order functions efficiently or at all. By defunctionalizing, you make the program purely first-order, which is easier to compile, analyze, serialize, or run in restricted environments.</p>
<h3 id="the-process"><a class="header" href="#the-process">The Process</a></h3>
<ol>
<li>Identify all possible higher-order functions that may be created and passed around.</li>
<li>Assign each such function a unique tag in an enum or sum type, along with any data it needs to operate.</li>
<li>Replace function values with these tags.</li>
<li>Define an <code>apply</code> function that takes a tag and the function arguments, then pattern matches on the tag to run the correct code.</li>
</ol>
<h3 id="example-in-rust"><a class="header" href="#example-in-rust">Example in Rust</a></h3>
<p>Before: using a closure</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let k: Box&lt;dyn Fn(i32) -&gt; i32&gt; = Box::new(|x| x + 1);
println!("{}", k(41));
<span class="boring">}</span></code></pre></pre>
<p>After: defunctionalized form</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Cont {
    Add1
}

fn apply(c: Cont, x: i32) -&gt; i32 {
    match c {
        Cont::Add1 =&gt; x + 1,
    }
}

println!("{}", apply(Cont::Add1, 41));
<span class="boring">}</span></code></pre></pre>
<h3 id="properties"><a class="header" href="#properties">Properties</a></h3>
<ul>
<li>All functions are now represented by simple data.</li>
<li>The program becomes purely first-order.</li>
<li>The <code>apply</code> function replaces direct function calls.</li>
</ul>
<h3 id="applications"><a class="header" href="#applications">Applications</a></h3>
<ul>
<li>Compiler backend simplification: many compilers generate CPS code and then defunctionalize it.</li>
<li>Serialization of functions: you can send the enum tag over a network or store it in a file.</li>
<li>Static analysis: first-order code is easier to reason about.</li>
<li>Derivation of interpreters: defunctionalization naturally leads to an interpreter pattern.</li>
</ul>
<h3 id="relation-to-cps"><a class="header" href="#relation-to-cps">Relation to CPS</a></h3>
<p>In CPS (continuation-passing style), continuations are higher-order functions. Defunctionalizing CPS code turns these continuations into a finite set of cases in an enum plus an apply function.</p>
<h3 id="relation-to-free-monads-1"><a class="header" href="#relation-to-free-monads-1">Relation to Free Monads</a></h3>
<p>A free monad can be seen as the result of defunctionalizing the continuations in a CPS-transformed program. The resulting data structure is the free monad's AST, and the apply function is the interpreter.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="dependent-types"><a class="header" href="#dependent-types">Dependent Types</a></h1>
<div id="admonition-related" class="admonition admonish-tip" role="note" aria-labelledby="admonition-related-title">
<div class="admonition-title">
<div id="admonition-related-title">
<p>Related</p>
</div>
<a class="admonition-anchor-link" href="concepts/dependent_types.html#admonition-related"></a>
</div>
<div>
<p>Insights: <a href="concepts/../insights/free-monad-dependent.html">Free Monad (dependently)</a></p>
</div>
</div>
<h3 id="definition-3"><a class="header" href="#definition-3">Definition</a></h3>
<p>A type system is called <em>dependent</em> when types can depend on values. This means that the shape, constraints, or meaning of a type may be parameterized by program values. With dependent types, you can express rich invariants and relationships directly in the type system.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<ul>
<li><code>Vec&lt;n, T&gt;</code> - a vector type indexed by its length <code>n</code></li>
<li><code>Matrix&lt;rows, cols, T&gt;</code> - dimensions encoded in the type</li>
<li><code>Proof&lt;p&gt;</code> - a type representing a proof of a proposition <code>p</code></li>
</ul>
<p>For instance, in a language with dependent types:</p>
<pre><code class="language-hs">append : Vec&lt;n, T&gt; -&gt; Vec&lt;m, T&gt; -&gt; Vec&lt;n + m, T&gt;
</code></pre>
<p>The type says that appending two vectors produces a vector whose length is the sum of the lengths.</p>
<h2 id="purpose"><a class="header" href="#purpose">Purpose</a></h2>
<ul>
<li>Capture <strong>invariants</strong> in the type system so they are checked at compile time</li>
<li>Reduce or eliminate certain classes of runtime errors</li>
<li>Allow programs to carry <strong>proofs</strong> of their own correctness</li>
<li>Enable more expressive APIs where type signatures encode precise behavior</li>
</ul>
<h2 id="key-characteristics"><a class="header" href="#key-characteristics">Key Characteristics</a></h2>
<ul>
<li><strong>Types are computed</strong>: Types can be expressions evaluated from program values</li>
<li><strong>Terms appear in types</strong>: No strict separation between values and types</li>
<li><strong>Type checking may evaluate code</strong>: The compiler may need to run computations to verify type constraints</li>
<li><strong>Expressiveness</strong>: Can model proofs, exact sizes, state transitions, or logical conditions</li>
</ul>
<h2 id="dependent-function-types"><a class="header" href="#dependent-function-types">Dependent Function Types</a></h2>
<p>A dependent function type is written (in type theory notation) as:</p>
<pre><code class="language-hs">Π x : A. B(x)
</code></pre>
<p>This means: for each value <code>x</code> of type <code>A</code>, the result type is <code>B(x)</code> which may depend on the value of <code>x</code>.</p>
<p>In programming terms:</p>
<ul>
<li>
<p>Non-dependent function:</p>
<pre><code class="language-hs">f : A -&gt; B
</code></pre>
<p>The output type <code>B</code> is fixed regardless of the input value.</p>
</li>
<li>
<p>Dependent function:</p>
<pre><code class="language-hs">f : (x : A) -&gt; B(x)
</code></pre>
<p>The output type varies based on the actual input <code>x</code>.</p>
</li>
</ul>
<h2 id="in-practice-1"><a class="header" href="#in-practice-1">In Practice</a></h2>
<ul>
<li>
<p>Fully supported in <strong>Agda</strong>, <strong>Idris</strong>, <strong>Coq</strong>, <strong>Lean</strong></p>
</li>
<li>
<p>Rust supports restricted forms via <strong>const generics</strong> and <strong>trait bounds</strong></p>
</li>
<li>
<p>Commonly used for:</p>
<ul>
<li>Exact-size arrays and matrices</li>
<li>State machines with type-level states</li>
<li>Encoding logical proofs alongside code</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="branching-and-confluence"><a class="header" href="#branching-and-confluence">Branching and Confluence</a></h1>
<p>We encounter <strong>branching</strong> constantly in everyday life.
Imagine:</p>
<ul>
<li>You wake up and decide: ☕ coffee <strong>or</strong> 🍵 tea.</li>
<li>If coffee: sugar or no sugar?</li>
<li>If tea: green or black?</li>
</ul>
<p>Each decision <strong>branches</strong> into alternatives, like a little decision tree.
But in the end, you don’t live in two universes — you end up with <strong>one drink in your hand</strong>.
That’s <strong>confluence</strong>: although choices branch, they merge back into one reality.</p>
<h2 id="branching-in-rust-programs"><a class="header" href="#branching-in-rust-programs">Branching in Rust Programs</a></h2>
<p>The same pattern appears in programs. A sequential program may branch internally, but execution always continues as a <strong>single flow</strong>.</p>
<h3 id="if"><a class="header" href="#if"><code>if</code></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sign(x: i32) -&gt; i32 {
    if x &gt; 0 {
        1
    } else if x &lt; 0 {
        -1
    } else {
        0
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Branching:</strong> program splits into one of three paths.</li>
<li><strong>Confluence:</strong> for a given input value, the same branch condition will always be chosen. Each input deterministically follows exactly one path, and evaluation of conditions happens in a fixed order (first check <code>x &gt; 0</code>, then <code>x &lt; 0</code>, else default). Regardless of which path is taken, the result is always determined from the input, and execution continues in a single, unified flow.</li>
</ul>
<h3 id="match"><a class="header" href="#match"><code>match</code></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn day_type(day: &amp;str) -&gt; &amp;str {
    match day {
        "Saturday" | "Sunday" =&gt; "Weekend",
        "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" =&gt; "Weekday",
        _ =&gt; "Unknown",
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Branching:</strong> many alternatives.</li>
<li><strong>Confluence:</strong> for a given input value, the program deterministically selects exactly one matching branch. The essential property is that the <em>trace</em> of evaluation is deterministic: the same input always leads down the same path. In this simple example each branch yields the same type (<code>&amp;str</code>), but even in settings with dependent types—where result types vary with input—the execution remains confluent because identical inputs always produce the same path and outcome.</li>
</ul>
<h3 id="loops-with-early-exit"><a class="header" href="#loops-with-early-exit">Loops with Early Exit</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_even(nums: &amp;[i32]) -&gt; Option&lt;i32&gt; {
    for &amp;n in nums {
        if n % 2 == 0 {
            return Some(n); // branch: exit early
        }
    }
    None // confluence: reached if loop completes
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Branching:</strong> may exit during iteration.</li>
<li><strong>Confluence:</strong> one thread of control — either returns early or finishes and continues.</li>
</ul>
<h2 id="sequential-confluence-illustrated"><a class="header" href="#sequential-confluence-illustrated">Sequential Confluence Illustrated</a></h2>
<pre><code>Start
 ├─ branch A → ...
 └─ branch B → ...
           ↘
            Confluence → continues as one flow
</code></pre>
<p>Just like your morning drink decision, a program doesn’t split into parallel worlds.
Branches are <strong>local alternatives</strong>, but <strong>sequential confluence</strong> ensures only one actual path is taken, and execution rejoins into one future.</p>
<p>⚡ <strong>Key idea:</strong>
Branching explores alternatives, confluence merges them back.
In sequential programs, <strong>confluence is guaranteed</strong>: there’s always one final thread of execution.</p>
<h2 id="confluence-beyond-determinism"><a class="header" href="#confluence-beyond-determinism">Confluence Beyond Determinism</a></h2>
<p>Confluence is often explained as the guarantee that the same input always produces the same output. But its essence is deeper: <strong>the trace of evaluation itself is deterministic</strong>. This means the path through the program is uniquely determined by the input, independent of external factors. In Rust, both <code>if</code> and <code>match</code> enforce deterministic traces. More broadly, confluence is what allows reasoning about programs algebraically, since the same input always reduces in a predictable way.</p>
<h2 id="trace-equivalence"><a class="header" href="#trace-equivalence">Trace Equivalence</a></h2>
<p><strong>Trace equivalence</strong> means that two programs, given the same input, follow evaluation paths that yield the <strong>same observable behavior</strong>: the same result and the same observable effects. In pure code (no effects), this reduces to producing the same result for all inputs. With side effects, equivalence also requires that the same conditions are evaluated in the same order.</p>
<p><strong>Example of not trace‑equivalent (side effect changes trace):</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_admin() -&gt; bool {
    println!("checked admin"); // side effect
    true
}
fn is_user() -&gt; bool {
    println!("checked user"); // side effect
    true
}

fn classify_role(x: i32) -&gt; &amp;'static str {
    if is_admin() {
        "admin"
    } else if is_user() {
        "user"
    } else {
        "other"
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here both <code>is_admin</code> and <code>is_user</code> return <code>true</code>, so the result is always <code>"admin"</code>. But the <strong>trace differs</strong>: if <code>is_admin</code> is checked first, only that prints; if conditions are reordered, <code>is_user</code> prints instead. The outcome is the same, but the traces differ, so the programs are <strong>not trace‑equivalent</strong>.</p>
<p><strong>Trace‑equivalent reorder (pure, disjoint, total):</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn classify_a(x: i32) -&gt; &amp;'static str {
    if x &lt; 0 { "neg" } else if x == 0 { "zero" } else { "pos" }
}
fn classify_b(x: i32) -&gt; &amp;'static str {
    if x == 0 { "zero" } else if x &lt; 0 { "neg" } else { "pos" }
}
<span class="boring">}</span></code></pre></pre>
<p>The predicates are disjoint and cover all integers; both versions return the same label for every input. With no side effects, these are <strong>trace‑equivalent</strong>.</p>
<h2 id="bridge-to-trees"><a class="header" href="#bridge-to-trees">Bridge to Trees</a></h2>
<p>Branching in programs naturally connects to tree structures. A sequence of decisions can be visualized as a decision tree: each internal node is a branching point, and each leaf is a possible outcome. Restricting to two alternatives at each branch gives <strong>binary trees</strong>, which are a cornerstone of computer science. This perspective shifts branching from a control-flow mechanism into a structural representation of possibilities.</p>
<p>Conal Elliott has described memory addressing as a kind of <strong>perfect binary leaf trees</strong>, where each memory cell corresponds to a leaf reached by a sequence of left/right choices. This view links the abstract branching structure of programs to the very way data is organized and accessed.</p>
<iframe width="100%" height="315" src="https://www.youtube.com/embed/oaIMMclGuog?si=qGfA1CWoDyXuInHA&amp;clip=Ugkx_TTQq7uzqaz9F1my5lozpOJ9cusgqSG3&amp;clipt=ELD_mwEY0LOeAQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<h2 id="bridge-to-semantics"><a class="header" href="#bridge-to-semantics">Bridge to Semantics</a></h2>
<p>Confluence is also a fundamental property in programming language semantics. In lambda calculus, for example, the <strong>Church–Rosser theorem</strong> states that if an expression can be reduced in different ways, all reduction paths will converge to a common result. This reflects the same guarantee as sequential confluence in Rust: different branches don’t lead to diverging realities but ultimately rejoin into one meaning. This bridge from everyday branching to formal semantics helps build intuition for deeper topics in programming theory.</p>
<h2 id="bridge-to-bisimulation"><a class="header" href="#bridge-to-bisimulation">Bridge to Bisimulation</a></h2>
<p>Another important concept related to branching is <strong>bisimulation</strong>, used in process calculi and concurrency theory. Two systems are bisimilar if they can simulate each other’s steps: whenever one makes a move, the other can make a corresponding move, and the resulting states remain related. Unlike simple trace equivalence, bisimulation is sensitive to the structure of branching, not just final results. It ensures that two programs behave the same way under every possible interaction, making it a powerful tool for reasoning about equivalence in concurrent and interactive systems.</p>
<p>There are different <strong>flavors</strong> of bisimulation:</p>
<ul>
<li><strong>Strong bisimulation</strong> – requires that every single step of one process can be matched by an identical step in the other, including internal or invisible actions.</li>
<li><strong>Weak bisimulation</strong> – abstracts away from internal or silent actions (often denoted τ). Two systems can be weakly bisimilar if they match on observable behavior, even if one performs extra internal steps.</li>
<li><strong>Branching bisimulation</strong> – a refinement of weak bisimulation that preserves the branching structure more carefully: even when ignoring internal actions, the branching points must align so that the choice structure is respected.</li>
</ul>
<p>These distinctions are crucial in concurrency theory: strong bisimulation is very strict, weak bisimulation allows flexibility with internal computation, and branching bisimulation balances the two by maintaining the essential shape of choices while abstracting from unobservable details.</p>
<h2 id="confluence-and-bisimulation-compared"><a class="header" href="#confluence-and-bisimulation-compared">Confluence and Bisimulation Compared</a></h2>
<p>Although confluence and bisimulation both deal with branching and outcomes, they apply in different contexts:</p>
<ul>
<li><strong>Confluence</strong> is about <strong>deterministic evaluation</strong>: for the same input, all reduction paths lead to the same result. It is mainly used in sequential semantics (e.g., lambda calculus) to prove consistency and simplify reasoning.</li>
<li><strong>Bisimulation</strong> is about <strong>behavioral equivalence</strong> between two possibly concurrent systems: whenever one system can make a step, the other can match it. It is mainly used in process calculi and concurrency theory to establish that two processes behave the same under all possible interactions.</li>
</ul>
<p>In short:</p>
<ul>
<li>Confluence → guarantees <strong>one meaning</strong> for each program.</li>
<li>Bisimulation → guarantees <strong>two programs mean the same</strong> in terms of behavior.</li>
</ul>
<p>These notions complement each other: confluence helps ensure determinism in sequential computation, while bisimulation provides a robust notion of equivalence in concurrent or interactive computation.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="operational-semantics-in-context"><a class="header" href="#operational-semantics-in-context">Operational Semantics in Context</a></h1>
<div id="admonition-related" class="admonition admonish-tip" role="note" aria-labelledby="admonition-related-title">
<div class="admonition-title">
<div id="admonition-related-title">
<p>Related</p>
</div>
<a class="admonition-anchor-link" href="insights/operational_semantics.html#admonition-related"></a>
</div>
<div>
<p>Concepts: <a href="insights/../concepts/operational_semantics.html">Operational Semantics</a>, <a href="insights/../concepts/free_monad.html">Free Monad</a>, <a href="insights/../concepts/cps.html">CPS</a>, <a href="insights/../concepts/defunctionalization.html">Defunctionalization</a></p>
</div>
</div>
<h2 id="why-operational-semantics-matters"><a class="header" href="#why-operational-semantics-matters">Why Operational Semantics Matters</a></h2>
<p>Operational semantics gives us the <strong>step-by-step execution model</strong> of a language.<br />
In ALUX, this plays a central role: it is the bridge between <strong>abstract meaning</strong> and <strong>concrete mechanics</strong>.</p>
<h2 id="connection-to-free-monads"><a class="header" href="#connection-to-free-monads">Connection to Free Monads</a></h2>
<p>A free monad describes a program as an <strong>AST of instructions</strong>.<br />
Interpreting this AST is essentially applying operational semantics:</p>
<ul>
<li><strong>Free monad</strong>: syntax of instructions + sequencing</li>
<li><strong>Operational semantics</strong>: rules that define how each instruction steps</li>
</ul>
<p>Thus, an interpreter for a free monad is <em>exactly</em> an operational semantics defined as code.</p>
<h2 id="connection-to-cps"><a class="header" href="#connection-to-cps">Connection to CPS</a></h2>
<p>Continuation-Passing Style (CPS) makes the <strong>rest of the computation</strong> explicit.<br />
Operational semantics can be expressed in CPS:</p>
<ul>
<li>Small-step rules correspond to continuations being applied after each instruction.</li>
<li>The operational machine is just a CPS interpreter in which the continuation is made first-class.</li>
</ul>
<p>This shows how CPS makes operational semantics executable.</p>
<h2 id="connection-to-defunctionalization"><a class="header" href="#connection-to-defunctionalization">Connection to Defunctionalization</a></h2>
<p>Defunctionalization takes CPS continuations and replaces them with <strong>explicit state transitions</strong>.<br />
This is precisely what operational semantics rules are:</p>
<ul>
<li>Continuation-as-function → State-transition-as-data</li>
<li>Apply function → Pattern match on instruction + next state</li>
</ul>
<p>The result is a <strong>transition system</strong> that matches the structure of operational semantics directly.</p>
<h2 id="real-example-the-evm"><a class="header" href="#real-example-the-evm">Real Example: The EVM</a></h2>
<p>The Ethereum Virtual Machine (EVM) can be understood operationally:</p>
<ul>
<li><strong>State</strong>: program counter, stack, memory, storage, gas</li>
<li><strong>Transition rules</strong>: one for each opcode (<code>ADD</code>, <code>PUSH</code>, <code>SSTORE</code>, etc.)</li>
<li><strong>Execution</strong>: repeatedly apply small-step rules until halting</li>
</ul>
<p>In ALUX terms:</p>
<ul>
<li>The <strong>EVM bytecode</strong> is a defunctionalized free monad program.</li>
<li>The <strong>EVM interpreter</strong> is its operational semantics.</li>
</ul>
<h2 id="dependent-types-as-enriched-semantics"><a class="header" href="#dependent-types-as-enriched-semantics">Dependent Types as Enriched Semantics</a></h2>
<p>Dependent types can enrich operational semantics with proofs:</p>
<ul>
<li><strong>Stack safety</strong>: <code>pop</code> only valid if stack depth &gt; 0</li>
<li><strong>Gas constraints</strong>: program type encodes available gas and its consumption</li>
<li><strong>Resource invariants</strong>: state transitions guaranteed by types</li>
</ul>
<p>This turns operational semantics from <em>rules for execution</em> into <em>proofs of correctness</em>.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>Operational semantics is the <strong>execution model</strong> of programs.</li>
<li>Free monads encode the same idea as syntax + sequencing.</li>
<li>CPS and defunctionalization provide mechanical ways to express operational semantics.</li>
<li>Real systems like the EVM are defunctionalized operational semantics in practice.</li>
<li>Dependent types elevate semantics into <strong>proof-carrying computations</strong>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="evm-as-a-virtual-machine"><a class="header" href="#evm-as-a-virtual-machine"><strong>EVM as a Virtual Machine</strong></a></h1>
<div id="admonition-related" class="admonition admonish-tip" role="note" aria-labelledby="admonition-related-title">
<div class="admonition-title">
<div id="admonition-related-title">
<p>Related</p>
</div>
<a class="admonition-anchor-link" href="insights/evm-alg.html#admonition-related"></a>
</div>
<div>
<p>Concepts: <a href="insights/../concepts/free_monad.html">Free Monad</a>, <a href="insights/../concepts/cps.html">CPS</a>, <a href="insights/../concepts/defunctionalization.html">Defunctionalization</a></p>
</div>
</div>
<p>The <strong>Ethereum Virtual Machine (EVM)</strong> is a stack-based virtual CPU that executes <strong>Ethereum bytecode</strong>. This bytecode is the compiled form of Ethereum smart contracts, usually written in Solidity, Vyper, or another EVM-compatible language.</p>
<p>At the lowest level:</p>
<ul>
<li>
<p>The EVM processes <strong>opcodes</strong> (ADD, PUSH, JUMP, SSTORE, etc.).</p>
</li>
<li>
<p>Execution state includes:</p>
<ul>
<li><strong>Stack</strong>: LIFO data stack for operand storage.</li>
<li><strong>Memory</strong>: transient byte array for temporary values.</li>
<li><strong>Storage</strong>: persistent key-value store for each contract.</li>
<li><strong>Program counter</strong>: points to the next opcode.</li>
<li><strong>Gas</strong>: metering system that charges for execution steps.</li>
</ul>
</li>
</ul>
<h2 id="evm-as-an-interpreter-pattern"><a class="header" href="#evm-as-an-interpreter-pattern"><strong>EVM as an Interpreter Pattern</strong></a></h2>
<p>From the free monad and GoF design patterns perspective:</p>
<ul>
<li><strong>Instruction Set</strong> = EVM opcodes (similar to your <code>enum Console</code>).</li>
<li><strong>Program AST</strong> = Actually, EVM code is <em>already compiled</em>, so it’s a flat sequence of instructions, not a rich high-level AST.
High-level languages like Solidity first have a compiler that builds an AST, optimizes it, and then emits EVM bytecode.</li>
<li><strong>Interpreter</strong> = The EVM specification defines how each opcode changes the machine state.</li>
<li><strong>Multiple interpreters</strong> = While the EVM spec is fixed, different clients (Geth, Nethermind, Besu, Erigon) are alternative implementations of the same interpreter.</li>
</ul>
<p>In GoF terms:</p>
<ul>
<li>The EVM is an <strong>Interpreter</strong> over an instruction language (bytecode).</li>
<li>Opcodes are <strong>Command objects</strong> executed in sequence.</li>
<li>The program state (stack, memory, storage) acts like the context in Interpreter pattern.</li>
</ul>
<h2 id="evm-and-free-monad-analogy"><a class="header" href="#evm-and-free-monad-analogy"><strong>EVM and Free Monad Analogy</strong></a></h2>
<p>If we model the EVM in a free monad style:</p>
<ol>
<li>
<p><strong>Syntax</strong>: Enum of opcodes with parameters, e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum EvmInstr&lt;A&gt; {
    Add(A),
    Push(U256, A),
    SStore(U256, U256, A),
    // ...
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Program</strong>: <code>Free&lt;EvmInstr, ()&gt;</code> would represent an abstract Ethereum program before compilation.</p>
</li>
<li>
<p><strong>Semantics</strong>: Interpreter function that executes these instructions against the EVM state.</p>
</li>
</ol>
<p>The difference:</p>
<ul>
<li>The real EVM executes a <strong>linear bytecode sequence</strong> (already defunctionalized into an array of low-level instructions).</li>
<li>A free monad version would allow you to build programs algebraically, chain them with <code>flat_map</code>, and then interpret or compile them into EVM bytecode.</li>
</ul>
<h2 id="evm-and-cps--defunctionalization"><a class="header" href="#evm-and-cps--defunctionalization"><strong>EVM and CPS / Defunctionalization</strong></a></h2>
<p>The EVM’s real execution loop is <strong>very similar to a defunctionalized CPS interpreter</strong>:</p>
<ul>
<li>In CPS: “do instruction, then call continuation”.</li>
<li>In EVM: “execute opcode, then increment program counter” is equivalent to applying the continuation for that instruction.</li>
<li>Defunctionalization: The “continuations” are already turned into a <strong>position in bytecode</strong> (program counter). This is the tag identifying the next action.</li>
<li>The interpreter (<code>switch</code> or <code>match</code> on opcode) is the <code>apply</code> function of the defunctionalized continuations.</li>
</ul>
<p>So:</p>
<ul>
<li><strong>CPS form</strong>: Smart contract execution as “do opcode → continuation”.</li>
<li><strong>Defunctionalized form</strong>: Replace continuations with <code>pc</code> + bytecode array.</li>
<li><strong>Free monad form</strong>: Build higher-level EVM programs before compiling them into the defunctionalized form.</li>
</ul>
<h2 id="key-insight"><a class="header" href="#key-insight"><strong>Key Insight</strong></a></h2>
<p>EVM execution = <strong>defunctionalized CPS interpreter</strong> for Ethereum bytecode.</p>
<div class="table-wrapper"><table><thead><tr><th>Concept</th><th>Free Monad World</th><th>EVM Reality</th></tr></thead><tbody>
<tr><td>Instruction type</td><td>Enum of opcodes</td><td>Fixed EVM opcodes</td></tr>
<tr><td>Program representation</td><td>AST built from <code>Free&lt;F, A&gt;</code></td><td>Linear bytecode array</td></tr>
<tr><td>Continuation</td><td>Closure in <code>FlatMap</code></td><td>Program counter (PC)</td></tr>
<tr><td>Interpreter</td><td>Pattern match on instruction enum</td><td>Switch on opcode, mutate VM state</td></tr>
<tr><td>Multiple interpreters</td><td>Different interpreters for same AST</td><td>Multiple Ethereum client implementations</td></tr>
</tbody></table>
</div>
<h1 id="mini-evm"><a class="header" href="#mini-evm">Mini EVM</a></h1>
<p>Here’s a <strong>mini-EVM in Rust</strong> using the same free monad style from the <code>Console</code> example, so you can clearly see the mapping to Ethereum’s real EVM execution model.</p>
<h2 id="1-instruction-set-evm-subset"><a class="header" href="#1-instruction-set-evm-subset">1. Instruction Set (EVM subset)</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
enum EvmInstr&lt;A&gt; {
    Push(u64, A),              // Push constant to stack
    Add(A),                    // Pop two, push sum
    SStore(u64, u64, A),       // Store key-value
    SLoad(u64, fn(u64) -&gt; A),  // Load value from storage
}
<span class="boring">}</span></code></pre></pre>
<h2 id="2-free-monad-core"><a class="header" href="#2-free-monad-core">2. Free Monad Core</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
enum Free&lt;F, A&gt; {
    Pure(A),
    Suspend(F),
    FlatMap(Box&lt;Free&lt;F, A&gt;&gt;, Box&lt;dyn Fn(A) -&gt; Free&lt;F, A&gt;&gt;),
}

impl&lt;F: Clone + 'static, A: 'static&gt; Free&lt;F, A&gt; {
    fn pure(a: A) -&gt; Self {
        Free::Pure(a)
    }
    fn flat_map&lt;B: 'static, G&gt;(self, f: G) -&gt; Free&lt;F, B&gt;
    where
        G: Fn(A) -&gt; Free&lt;F, B&gt; + 'static,
    {
        match self {
            Free::Pure(a) =&gt; f(a),
            other =&gt; Free::FlatMap(Box::new(other), Box::new(f)),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="3-smart-constructors"><a class="header" href="#3-smart-constructors">3. Smart Constructors</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn push(val: u64) -&gt; Free&lt;EvmInstr&lt;()&gt;, ()&gt; {
    Free::Suspend(EvmInstr::Push(val, ()))
}

fn add() -&gt; Free&lt;EvmInstr&lt;()&gt;, ()&gt; {
    Free::Suspend(EvmInstr::Add(()))
}

fn sstore(key: u64, value: u64) -&gt; Free&lt;EvmInstr&lt;()&gt;, ()&gt; {
    Free::Suspend(EvmInstr::SStore(key, value, ()))
}

fn sload(key: u64) -&gt; Free&lt;EvmInstr&lt;u64&gt;, u64&gt; {
    Free::Suspend(EvmInstr::SLoad(key, Free::pure))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="4-evm-state"><a class="header" href="#4-evm-state">4. EVM State</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

struct EvmState {
    stack: Vec&lt;u64&gt;,
    storage: HashMap&lt;u64, u64&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="5-interpreter"><a class="header" href="#5-interpreter">5. Interpreter</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_evm&lt;A&gt;(mut prog: Free&lt;EvmInstr&lt;A&gt;, A&gt;, state: &amp;mut EvmState) -&gt; A {
    loop {
        match prog {
            Free::Pure(a) =&gt; return a,
            Free::Suspend(EvmInstr::Push(v, next)) =&gt; {
                state.stack.push(v);
                prog = Free::Pure(next);
            }
            Free::Suspend(EvmInstr::Add(next)) =&gt; {
                let b = state.stack.pop().unwrap();
                let a = state.stack.pop().unwrap();
                state.stack.push(a + b);
                prog = Free::Pure(next);
            }
            Free::Suspend(EvmInstr::SStore(k, v, next)) =&gt; {
                state.storage.insert(k, v);
                prog = Free::Pure(next);
            }
            Free::Suspend(EvmInstr::SLoad(k, cont)) =&gt; {
                let val = *state.storage.get(&amp;k).unwrap_or(&amp;0);
                prog = cont(val);
            }
            Free::FlatMap(inner, cont) =&gt; match *inner {
                Free::Pure(a) =&gt; prog = cont(a),
                Free::Suspend(op) =&gt; prog = Free::Suspend(op),
                _ =&gt; unreachable!(),
            },
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="6-example-program"><a class="header" href="#6-example-program">6. Example Program</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let program = push(2)
        .flat_map(|_| push(3))
        .flat_map(|_| add())
        .flat_map(|_| sstore(1, 5))
        .flat_map(|_| sload(1))
        .flat_map(|val| push(val));

    let mut state = EvmState {
        stack: vec![],
        storage: HashMap::new(),
    };

    run_evm(program, &amp;mut state);

    println!("Final stack: {:?}", state.stack);
    println!("Storage: {:?}", state.storage);
}</code></pre></pre>
<h2 id="7-how-this-maps-to-the-real-evm"><a class="header" href="#7-how-this-maps-to-the-real-evm">7. How This Maps to the Real EVM</a></h2>
<ul>
<li><strong><code>EvmInstr</code> enum</strong> = EVM opcode set (syntax).</li>
<li><strong><code>Free&lt;EvmInstr, A&gt;</code></strong> = Abstract EVM program before compilation.</li>
<li><strong><code>run_evm</code></strong> = Interpreter (like Geth, Besu, Nethermind).</li>
<li><strong><code>EvmState</code></strong> = EVM stack, memory, and storage.</li>
<li>The <code>FlatMap</code> continuations here are <strong>exactly what the real EVM defunctionalizes</strong> into a program counter and bytecode array.</li>
</ul>
<p>Here is the defunctionalized mini-EVM: continuations are replaced by a program counter.</p>
<h2 id="core-idea"><a class="header" href="#core-idea">Core idea</a></h2>
<ul>
<li>Continuation in Free <code>FlatMap</code> becomes an integer <code>pc</code>.</li>
<li>Program is a flat <code>Vec&lt;Op&gt;</code>.</li>
<li>The interpreter is a loop that reads <code>code[pc]</code>, mutates state, then updates <code>pc</code>.</li>
</ul>
<h2 id="rust-code"><a class="header" href="#rust-code">Rust code</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap

#[derive(Clone, Debug)]
enum Op {
    Push(u64),
    Add,
    SStore(u64, u64),
    SLoad(u64),       // pushes value at key
    Halt,
}

#[derive(Default)]
struct VM {
    pc: usize,
    stack: Vec&lt;u64&gt;,
    storage: HashMap&lt;u64, u64&gt;,
    code: Vec&lt;Op&gt;,
}

impl VM {
    fn new(code: Vec&lt;Op&gt;) -&gt; Self {
        VM { code, ..Default::default() }
    }

    fn step(&amp;mut self) -&gt; bool {
        match self.code.get(self.pc).cloned().unwrap_or(Op::Halt) {
            Op::Push(v) =&gt; {
                self.stack.push(v);
                self.pc += 1;
            }
            Op::Add =&gt; {
                let b = self.stack.pop().expect("stack underflow")
                let a = self.stack.pop().expect("stack underflow")
                self.stack.push(a + b);
                self.pc += 1;
            }
            Op::SStore(k, v) =&gt; {
                self.storage.insert(k, v);
                self.pc += 1;
            }
            Op::SLoad(k) =&gt; {
                let v = *self.storage.get(&amp;k).unwrap_or(&amp;0);
                self.stack.push(v);
                self.pc += 1;
            }
            Op::Halt =&gt; return false,
        }
        true
    }

    fn run(&amp;mut self) {
        while self.step() {}
    }
}

fn main() {
    // Program: push 2; push 3; add; sstore 1,5; sload 1; halt
    let code = vec![
        Op::Push(2),
        Op::Push(3),
        Op::Add,
        Op::SStore(1, 5),
        Op::SLoad(1),
        Op::Halt,
    ]

    let mut vm = VM::new(code)
    vm.run()

    println!("Final stack: {:?}", vm.stack)
    println!("Storage: {:?}", vm.storage)
}</code></pre></pre>
<h2 id="mapping-to-free-and-cps"><a class="header" href="#mapping-to-free-and-cps">Mapping to Free and CPS</a></h2>
<ul>
<li>Free continuation <code>Fn(A) -&gt; Free</code> is now the integer <code>pc</code>.</li>
<li><code>match</code> on <code>Op</code> is the defunctionalized apply function.</li>
<li><code>Vec&lt;Op&gt;</code> is the defunctionalized program - a linear bytecode.</li>
<li>The loop <code>while self.step()</code> is the CPS trampoline without closures.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="free-monads-with-dependent-types"><a class="header" href="#free-monads-with-dependent-types">Free Monads with Dependent Types</a></h1>
<div id="admonition-related" class="admonition admonish-tip" role="note" aria-labelledby="admonition-related-title">
<div class="admonition-title">
<div id="admonition-related-title">
<p>Related</p>
</div>
<a class="admonition-anchor-link" href="insights/free-monad-dependent.html#admonition-related"></a>
</div>
<div>
<p>Concepts: <a href="insights/../concepts/free_monad.html">Free Monad</a>, <a href="insights/../concepts/dependent_types.html">Dependent Types</a></p>
</div>
</div>
<h2 id="dependent-types-as-a-natural-fit"><a class="header" href="#dependent-types-as-a-natural-fit">Dependent Types as a Natural Fit</a></h2>
<p>Free monads describe computations as <strong>data</strong>.
Dependent types allow us to express <strong>properties of these computations in their types</strong>.
By combining the two, we can write programs that are:</p>
<ul>
<li><strong>Easier to compose</strong> because type constraints guide construction</li>
<li><strong>Safer</strong> because invalid programs cannot type-check</li>
<li><strong>Self-documenting</strong> because the type itself encodes a specification</li>
<li><strong>Proof-carrying</strong> because the type may serve as a logical statement and the program as its proof</li>
</ul>
<h2 id="making-composition-easier"><a class="header" href="#making-composition-easier">Making Composition Easier</a></h2>
<p>In a non-dependent setting, a free monad type might look like:</p>
<pre><code class="language-hs">Free&lt;F, A&gt;
</code></pre>
<p>where <code>F</code> is the instruction set and <code>A</code> is the return value type.</p>
<p>With dependent types, we can enrich this to:</p>
<pre><code class="language-hs">Free&lt;F, A, P&gt;
</code></pre>
<p>where <code>P</code> is a <strong>predicate or property</strong> about the program.
The type system can ensure that when two programs are composed with <code>flat_map</code>, the resulting program's property is automatically derived from the inputs.</p>
<p>Example:</p>
<pre><code class="language-hs">Free&lt;EvmInstr, A, GasUsed &lt;= Limit&gt;
</code></pre>
<p>The type carries a proof that the program's gas usage is below the limit.</p>
<h2 id="turning-programs-into-proofs"><a class="header" href="#turning-programs-into-proofs">Turning Programs into Proofs</a></h2>
<p>In dependent type theory, a type can represent a proposition and a term of that type is a proof.
A free monad program can be viewed as a <strong>construction of a proof</strong> about the sequence of instructions.</p>
<p>Example in a dependently typed language:</p>
<pre><code class="language-hs">-- In Idris/Agda style
data Program : GasLimit -&gt; GasLimit -&gt; Type -&gt; Type where
  Pure   : A -&gt; Program g g A
  Instr  : F X -&gt; Program g1 g2 X -&gt; Program g1 g2 A
</code></pre>
<p>Here:</p>
<ul>
<li>The type <code>Program g_in g_out A</code> says that running the program transforms the available gas from <code>g_in</code> to <code>g_out</code> and produces an <code>A</code>.</li>
<li>Writing a program of this type is a proof that the gas accounting is correct.</li>
</ul>
<h2 id="benefits-over-plain-free-monads"><a class="header" href="#benefits-over-plain-free-monads">Benefits Over Plain Free Monads</a></h2>
<p>Without dependent types:</p>
<ul>
<li>Safety relies on runtime checks or careful manual construction.</li>
<li>Properties like "stack never underflows" or "resource usage within bounds" require testing or external proofs.</li>
</ul>
<p>With dependent types:</p>
<ul>
<li>The type system enforces these properties during program construction.</li>
<li>A well-typed program is already a <strong>certificate</strong> that it satisfies the desired property.</li>
</ul>
<h2 id="example-safe-stack-operations"><a class="header" href="#example-safe-stack-operations">Example: Safe Stack Operations</a></h2>
<p>Plain free monad:</p>
<pre><code class="language-hs">push : Val -&gt; Free&lt;StackInstr, ()&gt;
pop  : Free&lt;StackInstr, Val&gt; -- may fail at runtime if empty
</code></pre>
<p>Dependent free monad:</p>
<pre><code class="language-hs">push : Val -&gt; Program&lt;Depth, Depth + 1, ()&gt;
pop  : Program&lt;Suc Depth, Depth, Val&gt; -- only type-checks if Depth &gt; 0
</code></pre>
<p>Here, the type encodes the <strong>stack depth</strong> before and after the operation.
An attempt to <code>pop</code> from an empty stack is a type error, not a runtime failure.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<ul>
<li>Dependent types turn free monads into <strong>proof-carrying programs</strong>.</li>
<li>They make composition easier by tracking and combining properties automatically.</li>
<li>They can statically guarantee safety and correctness without runtime checks.</li>
<li>The type of a free monad program can <em>be</em> the proposition it proves.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="about"><a class="header" href="#about">About</a></h1>
<p>This book distills a way of thinking about software inspired by Conal Elliott’s <strong>Denotational Design</strong>.
The core idea is simple yet profound:</p>
<div id="admonition-denotational-design" class="admonition admonish-note" role="note" aria-labelledby="admonition-denotational-design-title">
<div class="admonition-title">
<div id="admonition-denotational-design-title">
<p>Denotational Design</p>
</div>
<a class="admonition-anchor-link" href="about.html#admonition-denotational-design"></a>
</div>
<div>
<p><em>Define the meaning of a program before deciding how it runs.</em></p>
</div>
</div>
<p>In this view, computation is not an opaque sequence of steps but a transparent mathematical object. We begin with <strong>specifications</strong> as pure, compositional descriptions of <em>what</em> a program means. These are expressed as algebraic structures, often in the form of traits or type signatures. The <strong>implementation</strong>, <em>how</em> those meanings are realized, is a separate, interchangeable layer.</p>
<p>By separating meaning from mechanics, we gain:</p>
<ul>
<li><strong>Clarity</strong> - programs read like precise definitions.</li>
<li><strong>Composability</strong> - parts fit together algebraically.</li>
<li><strong>Refactorability</strong> - meaning stays fixed while implementation evolves.</li>
<li><strong>Correctness</strong> - reasoning about programs becomes equational, not operational.</li>
</ul>
<p>These guidelines aim to provide practical techniques for applying this style in modern programming languages, especially Rust, without losing the elegance and rigor of its mathematical roots.</p>
<h2 id="reference-of-mdbook"><a class="header" href="#reference-of-mdbook">Reference of mdbook</a></h2>
<p><a href="https://rust-lang.github.io/mdBook/index.html">mdBook documentation</a></p>
<h2 id="reference-of-admonish-mdbook-plugin-tooltip-boxes"><a class="header" href="#reference-of-admonish-mdbook-plugin-tooltip-boxes">Reference of <strong>admonish</strong> mdbook plugin (tooltip boxes)</a></h2>
<p><a href="https://tommilligan.github.io/mdbook-admonish/">admonish documentation</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
